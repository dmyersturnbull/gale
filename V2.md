

# Gale

Gale is a domain-specific language to **build and compute arbitrarily sized vectors and matrices** in one line.

It seamlessly applies operations to scalars, vectors, and matrices and sports functions for linear algebra, statistics, random distributions, combinatorics, and signal processing. You can use it to define features to calculate on a video stream, build random vectors or matrices, or schedule events.

It was designed for users with some math but little or no programming knowledge. There are no loops, variables, or scope. It's purely functional and uses type inference.
Here are some 1-line programs. Note the use of `i`,`j`, and `$`:
- `i + j` ← a matrix of arbitrary size
- `$${-1} + rand.norm(1,1)` ← Brownian motion (submartingale)
- `mean($${-1..-3}) + rand.norm(1,1)` ← same, but average the last 3 (or max available)
- `if(i<=j -> comb.stirling2(i, j))` ← upper-triangular matrix of Stirling numbers of the 2nd kind
- `count(abs($m-$m{-1}) >= 2)` ← count matrix elements that changed by >±1.

The last example requires a series of input matrices/vectors called _m_: plain `m` is the _current_ input while `m{-1}` is the previous one. The parser knows from the definition that it should _slide_ over a series of `m`, regardless of the shape. It also knows from the _-1_ to keep only two elements in memory at a time (if the data is streamed).
You could instead have it slide over two axes (i _and_ j) by substituting `m{-1}` with `m{-1,-1}`.

Formally, it's a parsing expression grammar (PEG).
Rules are pretty simple: operators map two inputs to the same type, i, j, and k are tensor indices, and curly braces reference previous elements, with `..` for a range. The `if` function works with the `->` symbol like this: `if(condition1 -> value1, condition2 -> value2, ..., elsevalue)`. If no condition matches (no `elsevalue`), the default value (normally 0) is returned. Indexing (with `$` and `{}`) is probably the only tricky syntax.  A syntax glossary is in the next section.

This package contains the grammars, a parser in Scala, a command-line tool, and a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop).
The dimensions, data type, and default values (for sparse matrices) are passed as arguments alongside the expression. Examples using the CLI:
```
>>> gale "sin(i)" 0..10 --dtype float --default neginf --round 2
-∞ 0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41

>>> gale "i" 0..10 --round 2 format hex8
00000000000000003FF000000000000040000000

>>> gale " i"    0..1000 --format raw >  file1.bytes
>>> gale "-i" 1000..2000 --format raw >> file1.bytes
```

#### Lots more examples

- `sin(i) + cos(j)` ← a matrix, [[0,1], ...]
- `i % 2` ← a vector, [0, 1, 0, 1, ...] 
- `if(i>0 and i>0 -> 1)`  ← [0, 0, 1, 0, 1, 0 ...]
- `if(1<i<4->1, i=4->2, 0)` ← [0, 0, 1, 1, 0, 2, 2, 2, ...]
- `i @ step(3)`  ← [0, 0, 0, 3, 3, 3, ...], re-evaluate every 3 steps
- `i%2 + 1` ← [1, 2, 1, 2, ...]
- `i/(i+1)` ← [1/2, 2/3, 3/4, ...]
- `rand.unif(1, 10)` ← uniform sampling
- `if(i>10 -> sum({-1..-3}))` ← sum the last 3 values
- `sum( sin({-1..-3}+1) )` ← apply operations elementwise
- `sum( sin({-1..-3,-1..-2}+1) )` ← apply operations to matrix elements
- `if(all(new.zeros(2,2)+1 = 1) -> 1))` ← [1, 1, ...]
- `if(t>10 -> mean({-1..-10}) + sample.norm(1,1))` ← a [submartingale](https://en.wikipedia.org/wiki/Martingale_(probability_theory)#Submartingales,_supermartingales,_and_relationship_to_harmonic_functions)
- `math.delta(i) + comb.choose(i, 2)` ← [∞, 0, 1, 3, 6, ...]
- `if(i<=j -> 1)` ← upper-triangular matrix
- `ioeis.A008277(i, j)` ← Stirling numbers of the 2nd kind


##### Syntax glossary

The grammar is whitespace- and case-insensitive.
Ten syntax elements are defined: (1) scalar (or string) literals, (2) operators, (3) functions, (4) parentheses for grouping, (5) the current indices (i, j, k), (6) the conditional symbol `->` for if statements, (7) comparison operators (`=`, `<`, `<=`, etc), (8) references (curly braces), (9) references with `$`, and (10) declarations with `:=`.

Data types:
- boolean, float, int
- row vector (of any scalar type)
- column vector (of any scalar type)
- matrix (of any scalar type)
- transposed matrix (of any scalar type)
- reference to index
- reference to previous value(s)
- conditional value
- declaration
- simple substitution
- function call


Glossary of syntax and operators:
- Escape: `\`
- Numeric literal: `5`, `5.5`
- Engineering notation literal: `1e-3`
- Infinite literals: `inf`, `-inf`
- Not-a-number literal: `NaN`
- Boolean literal: `true`, `false`
- Operation grouping: `()`
- Unary minus: `-`
- Numerical operators: `+`, `-`, `*`, `/`
- Matrix multiplication: `*`
- Exponentiation: `^`
- Modulus operator: `%`
- String concatenation: `+`
- Elementwise binary operators: `:&`, `:|`, `:!&`, `:!|`, `:^`, `:!^`
- Bitwise operators: `.&`, `.|`, `.!&`, `.!|`, `.^`,  `.!^`, `.<<`, `.>>`, `.>>>`
- Boolean operators: `and`, `or`, `nand`, `nor`, `xor`
- Equality pseudo-operator: `=`, `==`
- Inequality pseudo-operator: `!=`
- Comparison pseudo-operators: `<`, `<=`, `>`, `>=`
- Approximate comparison pseudo-operators:  `~=`, `!~=`
- Step/convolution pseudo-operator: `@`
- Crop operator: `\\`
- Indices: `i`, `j`, `k`
- Access to input _name_ at $i-n$: `$name{-n}`
- Access to output value at $i-n$: `$${-n}`
- Previous value: `{-x}`, `{-x,-y}`, `{-x,-y,-z}`
- Slice of values: `{-x..-y}`, `{-x..-y,-z..-w}`, `{-x..y,-z..-w,-v..-w}`
- Special argument list: `(1,2..3,4..,5,6)` or `((1,2)..(3,4)..(5,6))`
- Function call: `function(x, y, ...)`,  `category.function(x, y, ...)`
- Conditional symbol: `->`
- If/then: `if(condition -> value)`
- If/then/else: `if(condition -> value, elsevalue)`
- if/then/elif: `if(condition -> value, condition -> value, ...)`
- If/then/elif/else: `if(condition -> value, condition -> value, ..., elsevalue)`
- Declaration: `$name := value`
- Simple substitution: `$name`

Reserved names with default values:
- Data type: `dtype := double` (can be `double`, `float`, `int`, `long`, or `byte`)
- Random seed: `$seed := <system>` (can be an integer, `<system>`, or `<given>`)
- Tolerance for approximate equality: `$tolerance := 1E-10`
- Default value when no _if_ condition matches: `$default := 0`
- Out-of-bounds access value: `$oob := NaN`

Special functions:
- Step function (evaluate every _n_ iterations): `@ step(n)`
- Indicator function: `ind`
- Existential quantification: `any`
- Universal quantification: `all`
- Count true: `count`
- Divides functions: `even`, `odd`, `divides`
- Get length: `n.length` (only vectors), `n.rows`, `n.cols`, `n.rowst`, `n.colst`

Numeric functions:
- Constants: `const.pi`, `const.e`
- Root functions: `sqrt`, `cbrt`, `root`
- Trig functions: `sin`, `cos`, `tan`, `asin`, `acos`, `atan`
- Exponential functions:`exp`, `pow`, `ln`, `log10`, `log2`, `sinh`, `cosh`, `tanh`, [`erf`](https://en.wikipedia.org/wiki/Error_function)
- Absolute value function: `abs`
- Rounding-like functions: `round`, `ceil`, `floor`, `clip`
- [Sign function](https://en.wikipedia.org/wiki/Sign_function): `sgn`
Basic aggregation functions: `sum`, `mean`, `min`, `max`
- Argmin/argmax: `argmin`, `argmax`
- Dot product: `dot`
- Determinant and trace: `det`, `trace`
- Transposition: `transpose`

Aggregation and statistics functions:
- Moments: `quantile`, `stddev`, `skewness`, `kurtosis`
- Other aggregation: `geomean`, `logsum`, [`sumsqr`](https://en.wikipedia.org/wiki/Total_sum_of_squares), [`rmsd`](https://en.wikipedia.org/wiki/Root-mean-square_deviation)
- Random sampling: `rand.unif`, `rand.norm`, `rand.beta`, `rand.exp`, `rand.gamma`, `rand.poisson`, `rand.dirichlet`,  `rand.bernoulli`, `rand.binom`
- Cumulative distribution functions: `cdf.unif`, `cdf.norm`, `cdf.beta`, `cdf.exp`, `cdf.gamma`, `cdf.poisson`, `cdf.dirichlet`
-  Continuous distribution function: `pdf.unif`, `pdf.norm`, `pdf.beta`, `pdf.exp`, `pdf.gamma`, `pdf.poisson`, `pdf.dirichlet`
- Discrete distribution function: `pmf.bernoulli`, `pmf.binom`, `cdf.bernoulli`, `cdf.binom`
- Distance functions:`dist.l0`, `dist.l1`, `dist.l2`, `dist.hamming`
- Norm functions: `norm.l0`, `norm.l1`, `norm.l2`

Image and morphology functions:
- `morph.dilation`, `morph.erosion`, `morph.opening`, `morph.closing`
- `shape.reflect.y`, `shape.reflect.x`
- `shape.rot90`, `shape.rot180`, `shape.rot270`
- `shape.rotate.deg!`, `shape.rotate.rad!`
- `shape.convexhull!`
- `shape.circle!`, `shape.square`, `shape.ellipse!`, `shape.rectangle`, `shape.triangle!`, `shape.hexagon!`
- `shape.draw!`

The `!` is used to indicate rounding of coordinates, which could be unexpected.
Shapes are closed loops described by vertices using coordinates of (0,0)..(1,1), where values are rounded. Ex:
`shape.draw!(0,0..0.2,0.3..1,1..0,0)`

Specialized functions:
- Number of digits: `n.digits`
- `wave.square`, `wave.saw`, `wave.triangle`
- `comb.fact`, `comb.choose`, `comb.perm`, `comb.stirling1`, `comb.stirling2`, `comb.bell`
- `math.shannon`, `math.logit`, `math.relu`, `math.sigmoid`, `math.softmax`
- `math.isprime`
- [Delta function](https://en.wikipedia.org/wiki/Dirac_delta_function): `math.delta`
- `hash.djb2`, `hash.adler32`, `hash.crc`, `hash.md5`, `hash.sha1`
- [OEIS lookup](https://oeis.org/) (extracted before parsing): `oeis.`

Constructing functions:
- `new.rvector`, `new.colvector`
- `new.matrix`
- `new.uppertri`, `new.lowertri`

You can do, ex: `transpose(new.uppertri(1, NaN))`


##### Formal description

This is written using [Extended Brackus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form) (EBNF).
Although the parser is written as a PEG, the grammar should be an unambiguous context-free grammar (CFG).

##### Equivalent symbols

- == → =
- != → ≠
- <= → ≤
- \>= → ≥
- and → ∧
- or → ∨
- nand → ⊼
- nor → ⊽
- xor → ⊻

