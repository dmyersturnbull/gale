
# Gale

Gale is a domain-specific language to **write and compute arbitrarily sized vectors and matrices**, often in one line.
It parses intuitive expressions and was designed for users with little or no programming knowledge. There are no loops, variables, statements, or scope. It's purely functional and uses type inference.
It seamlessly applies operations to scalars, vectors, and tensors and sports functions for linear algebra, statistics, random distributions, combinatorics, strings, and signal processing. Some examples:
- `i + j + k` ← a 3-d array
- `if(i>0, mean({-1}) + rand.norm(1,1))` ← a submartingale
- `if(i<=j, ioeis.A008277(i, j))` ← Stirling numbers of the 2nd kind

Formally, it's a collection of three parsing expression grammars (PEGs) for floats, integers, and strings. Operations are normally defined only if they can't fail: For example, division isn't defined in the integer grammar. (The exceptions are division by zero, functions on NaN, ∞, or -∞, and incompatibility of matrix dimensions.)
Rules are pretty simple: operators (symbols) map to the same type, i, j, and k are tensor indices, and curly braces reference previous elements.

This package contains the grammars, a parser in Scala, and a command-line parser.
The dimensions, data type, and default value are optional arguments alongside the expression. Examples using the CLI:
```
>>> gale "sin(i)" 0-10 --dtype float --default neginf --round 2
-∞ 0.84 0.91 0.14 -0.76 -0.96 -0.28 0.66 0.99 0.41

>>> gale "i" 0-10 --round 2 format hex8
00000000000000003FF000000000000040000000

>>> gale " i" 0-1000   " --format raw >  file1.bytes
>>> gale "-i" 1000-2000" --format raw >> file1.bytes
```

#### Lots more examples

- `sin(i) + cos(j)` ← a matrix, [[0,1], ...]
- `i % 2` ← a vector, [0, 1, 0, 1, ...] 
- `if(i>0 and i>0 -> 1)`  ← [0, 0, 1, 0, 1, 0 ...]
- `if(1<i<4, 1, if(i=4, 2))` ← [0, 0, 1, 1, 0, 2, 2, 2, ...]
- `i every 3`  ← [0, 0, 0, 3, 3, 3, ...], re-evaluate every 3 steps
- `i%2 + 1` ← [1, 2, 1, 2, ...]
- `i/(i+1)` ← [1/2, 2/3, 3/4, ...]
- `rand.unif(1, 10)` ← uniform sampling
- `if(i>10, sum([-1..-3]))` ← sum the last 3 values
- `sum( sin({-1..-3}+1) )` ← apply operations elementwise
- `sum( sin({-1..-3,-1..-2}+1) )` ← apply operations to matrix elements
- `if(all(new.zeros(2,2)+1 = 1), 1))` ← [1, 1, ...]
- `if(t>10, mean({-1..-10}) + sample.norm(1,1))` ← a [submartingale](https://en.wikipedia.org/wiki/Martingale_(probability_theory)#Submartingales,_supermartingales,_and_relationship_to_harmonic_functions)
- `math.delta(i) + comb.choose(i, 2)` ← [∞, 0, 1, 3, 6, ...]
- `if(i<=j, 1)` ← upper-triangular matrix
- `ioeis.A008277(i, j)` ← Stirling numbers of the 2nd kind


##### A few notes

1. The grammar is whitespace- and case-insensitive. Both _=_ and _==_ are fine for equality.
2. To simplify writing sparse matrices, values are 0 if no _if/elif_ condition matches. This value can be changed (see the `--default` argument above).


##### List of terms and operators

Only a few syntax elements are defined: scalars, operators (symbols), functions (alphanumeric+dot), the current indices (i, j, k), references to previous elements (curly braces), declarations with `:=`, and the `step` keyword.

Statements, operators, and syntax:
- `if`, `elif`, `else`
- `{-x}` ← access to previous element x
- `{-x..-y}` ← access to elements x to y
- `{-x..-y,-w..-z}` ← access to matrix elements
- `()` ← group operations
- `every n` ← step size, evaluate every _n_ items
- `+`, `-`, `*`, `/`, [`%`](https://en.wikipedia.org/wiki/Modulo_operation), [`^`](https://en.wikipedia.org/wiki/Exponentiation)
- `==`, `=`, `<`, `>`, `<=`, `>=`, `!=`
- `~=`, `!~=` ← approximate equality; tolerance set as an argument
- `and`, `or`, `nand`, `nor`, `xor`
- `nan`, `inf`, `ninf`
- `bool` ← turn a condition into 0 or 1

Functions:
- `sin`, `cos`, `tan`, `asin`, `acos`, `atan`
- `sqrt`, `exp`, `pow`, `ln`, `log10`, `log2`, `sinh`, `cosh`, `tanh`, [`erf`](https://en.wikipedia.org/wiki/Error_function)
- `abs`, `round`, `ceil`, `floor`, `clip`
- [`sgn`](https://en.wikipedia.org/wiki/Sign_function), [`ind`](https://en.wikipedia.org/wiki/Indicator_function)
- `sum`, `mean`, `min`, `max`, `argmin`, `argmax`
- `new.zeros`, `new.ones`
- `any`, `all`
- `digit`
- `even`, `odd`, `divides`

Linear algebra functions:
`slice`, `col`, `row`, `element`
- 	`det`, `trace`

Aggregation and statistics functions:
- `quantile` `geomean`, `stddev`, `skewness`, `kurtosis`
- `logsum`, [`sumsqr`](https://en.wikipedia.org/wiki/Total_sum_of_squares), [`rmsd`](https://en.wikipedia.org/wiki/Root-mean-square_deviation)
- `rand.unif`, `rand.norm`, `rand.beta`, `rand.exp`, `rand.gamma`, `rand.poisson`, `rand.dirichlet`,  `rand.bernoulli`, `rand.binom`

Specialized functions:

- `cdf.unif`, `cdf.norm`, `cdf.beta`, `cdf.exp`, `cdf.gamma`, `cdf.poisson`, `cdf.dirichlet`
- `pdf.unif`, `pdf.norm`, `pdf.beta`, `pdf.exp`, `pdf.gamma`, `pdf.poisson`, `pdf.dirichlet`
- `pmf.bernoulli`, `pmf.binom`, `cdf.bernoulli`, `cdf.binom`
- `dist.l0`, `dist.l1`, `dist.l2`, `dist.hamming`, `norm.l0`, `norm.l1`, `norm.l2`
- `math.pi`, `math.e`, [`math.delta`](https://en.wikipedia.org/wiki/Dirac_delta_function)
- `wave.square`, `wave.saw`, `wave.triangle`
- `comb.fact`, `comb.choose`, `comb.perm`
- `math.shannon`, `math.logit`, `math.relu`, `math.sigmoid`, `math.softmax`
- `hash.djb2`, `hash.adler32`, `hash.crc`, `hash.md5`, `hash.sha1`
- `z.byte` ← round and constrain between 0 and 255
- `z.percent` ← round and constrain between 0 and 100
- `parrot` ← ASCII art of a parrot
- [`oeis.`](https://oeis.org/) (_extracted before parsing_)


##### Formal description

This is written using [Extended Brackus–Naur form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form) (EBNF).
Although the parser is written as a PEG, the grammar should be an unambiguous context-free grammar (CFG).

##### Symbols

Shorthand symbols can be used.

- == → =
- != → ≠
- <= → ≤
- \>= → ≥
- and → ∧
- or → ∨
- nand → ⊼
- nor → ⊽
- xor → ⊻

